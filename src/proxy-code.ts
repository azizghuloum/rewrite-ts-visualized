import { assert } from "./assert";
import { modular_extension } from "./stx";
import { Context, Env } from "./syntax-structures";

function extract_bindings(
  env: Env,
  binding_type: "lexical" | "type",
  context: Context,
): { [k: string]: string } {
  const a: { [k: string]: string } = {};
  Object.entries(env).forEach(([original_name, ls]) => {
    assert(ls.length !== 0);
    assert(
      ls.length === 1,
      `duplicate export of '${original_name}' (some might be generated by a rewrite)`,
    );
    assert(a[original_name] === undefined, `duplicate export of '${original_name}'`);
    const [_marks, label] = ls[0];
    const binding = context[label.name];
    assert(binding !== undefined);
    assert(binding.type === binding_type);
    const new_name = binding.name;
    a[original_name] = new_name;
  });
  return a;
}

export function generate_proxy_code(
  import_path: string,
  modular: modular_extension,
  context: Context,
): string {
  assert(modular.extensible);
  const { explicit } = modular;
  const vars = extract_bindings(explicit.normal_env, "lexical", context);
  const types = extract_bindings(explicit.types_env, "type", context);
  const imports = [...Object.values(vars), ...Object.values(types).map((t) => `type ${t}`)].join(
    ", ",
  );
  const lines = [
    `/* This is an automatically generated file.  Do not edit. */`,
    `import { ${imports} } from ${JSON.stringify(import_path)};`,
    ...Object.entries(vars).map(([name, imp]) => `export { ${imp} as ${name} };`),
    ...Object.entries(types).map(([name, imp]) => `export type ${name} = ${imp};`),
    "",
  ];
  return lines.join("\n");
}
